//using color = vec3;
//Any time useing 'colorRGB' it will be a vec3
#define colorRGB vec3

//Anytime used colorRGBA it will be a vec4
#define colorRGBA vec4

// Method found in an youtube channel Lewis Lepton
// Link to youtube video to make cirlce: https://www.youtube.com/watch?v=9oYssHkOn0I
// Link to youtube video to make it pulse: https://www.youtube.com/watch?v=gxOfjRT5CMA&t=41s
vec4 myEffect2Cricle(in vec2 fragCoord, in float radius)
{
    vec2 uv = fragCoord.xy; //Gets pixel cordinates
    
    vec3 color = vec3 (0.0); //setting up color
    
    //Incharge of the sin change over time
    vec2 scale = vec2(sin(iTime) + 2.0);
    
    //Actualy scaling the circle
    uv -= vec2(0.5);
    uv = mat2(scale.x, 0.0, 0.0, scale.y) * uv;
    uv += vec2(0.5);
    
    //Step is a step funiction that will return 0.0 or 1.0 (depending on what was put in)
    //Length returns the length of a vector
    //Mulitpling resolutions here because I found it to fix my screen problem
    float circle = step(radius * iResolution.y, length(uv - vec2(iResolution.xy * 0.5))); 
    
    color += vec3(circle, 0.2, 1.0); //Draws circle and colors it blue and pink
    
    return vec4(color, 1.0); //Returns circle
    
}

vec4 myEffect1Checkers(in vec2 fragCoord)
{
    // Not fully original work! 
    // Source for grid came from: https://www.shadertoy.com/view/XtBBRw
    // This is the best way I could find on sourcing this work
    
    vec2 uv = fragCoord / vec2(100);
    float cord = mod(floor(uv.x) + floor(uv.y), 2.0); //this is mod(genFType x, float y);
    return vec4(vec3(cord), 1.0);
}
 

vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    //color is 0 to 1 and coord is 0 to res
    //R and B -> horizontal
    //G and A -> vertical
    //return vec4(fragCoord, fragCoord);
    
    //Fix: red and green only
    //R -> horizontal
    //G -> vertical
    //return vec4(fragCoord, 0.0, 1.0);
    
    //final: red-green gradient
    //vec2 uv = fragCoord / iResolution.xy;
    //return vec4(uv, 0.0, 1.0);
    
    //fun: red-green gradient
    vec2 uv = fragCoord / resolution;
    //return vec4(0.5, uv, 1.0);
    
    vec3 color = vec3(uv, 0.25);
    float alpha = 1.0;
    return vec4(color, alpha);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //Actual calling of functions for project
    
    // Effect 0
    //fragColor = myEffect0(fragCoord, iResolution.xy);
    
    // Effect 1
    //fragColor = myEffect1Checkers(fragCoord);
    
    // Effect 2
    fragColor = myEffect2Cricle(fragCoord, 0.3);
    
    
    
    // Other notes taken in class
    // Also graident color change was written when file was made
    
    //R,G,B,A = [0,1]
    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);
    
    // Normalized pixel coordinates (from 0 to 1)
    //vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    //fragColor = vec4(col,1.0);
}