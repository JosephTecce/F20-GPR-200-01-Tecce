// Code written and commented by: Joseph Tecce
// Using Shadertoys copyright agreement

//using color = vec3;
//Any time useing 'colorRGB' it will be a vec3
#define colorRGB vec3

//Anytime used colorRGBA it will be a vec4
#define colorRGBA vec4

// Effect was inspired by online youtube 
// video : https://www.youtube.com/watch?v=VxGfhPeeXqs&list=PL4neAtv21WOmIrTrkNO3xCyrxg4LKkrF7&index=16
vec4 myEffect4Bonus(in vec2 fragCoord)
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord / iResolution.xy;
    
    // Made a variation were only taking sin.x over time
    // Made a variation were only taking cos.y over time
    // Made another variation were sin.y is a tan, and cos.x is a tan
    vec2 sinWave = vec2(0.5 / sin(uv.x + iTime), tan(uv.x + iTime)); //Deviding by sin to make cool line effect
    vec2 cosWave = vec2(tan(uv.y + iTime), 1.0 / cos(uv.y + iTime)); //Deviding by cos to make cool line effect
    
    // Combining the cos.y and sin.x wave made above
    // tan added to make harsher edgese to effect making it more clear
    vec3 col = vec3(cos(cosWave.x), (sinWave.x), tan((cosWave.x + cosWave.y) - (sinWave.x + sinWave.y)));

    // return to main function
    return vec4(col,1.0);
}

// Effect was inspired by online youtube 
// video : https://www.youtube.com/watch?v=VxGfhPeeXqs&list=PL4neAtv21WOmIrTrkNO3xCyrxg4LKkrF7&index=16
vec4 myEffect3Trip(in vec2 fragCoord)
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord / iResolution.xy;
    
    // Makeing "sin" wave and "cos" wave
    // Made a variation were only taking sin.x over time
    // Made a variation were only taking cos.y over time
    vec2 sinWave = vec2(sin(uv.x + iTime), sin(uv.x + iTime));
    vec2 cosWave = vec2(cos(uv.y + iTime), cos(uv.y + iTime));
    
    // Combining the cos.y and sin.x wave made above
    // tan added to make harsher edgese to effect making it more clear
    vec3 col = vec3(cos(cosWave.x), cos(sinWave.x), tan((cosWave.x + cosWave.y) - (sinWave.x + sinWave.y)));

    // return to main function
    return vec4(col,1.0);
}

// Method found in an youtube channel Lewis Lepton
// Link to youtube video to make cirlce: https://www.youtube.com/watch?v=9oYssHkOn0I
// Link to youtube video to make it pulse: https://www.youtube.com/watch?v=gxOfjRT5CMA&t=41s
vec4 myEffect2Cricle(in vec2 fragCoord, in float radius)
{
    vec2 uv = fragCoord.xy; //Gets pixel cordinates
    
    vec3 color = vec3 (0.0); //setting up color
    
    vec2 scale = vec2(sin(iTime) + 2.0); //Change scale of circle over time
    
    uv -= vec2(0.5);
    uv = mat2(scale.x, 0.0, 0.0, scale.y) * uv;
    uv += vec2(0.5);
    
    //Step is a step funiction that will return 0.0 or 1.0 (depending on what was put in)
    //Length returns the length of a vector
    //Mulitpling resolutions here because I found it to fix my screen problem
    float circle = step(radius * iResolution.y, length(uv - vec2(iResolution.xy * 0.5))); 
    
    color += vec3(circle, 0.2, 1.0); //Draws circle and colors it blue and pink
    
    return vec4(color, 1.0); //Returns circle
    
}

vec4 myEffect1Checkers(in vec2 fragCoord)
{
    // Not fully original work! 
    // Source for grid came from: https://www.shadertoy.com/view/XtBBRw
    // This is the best way I could find on sourcing this work
    vec2 uv = fragCoord / vec2(100); //One way found to make perfect squares
    float color = mod(floor(uv.x) + floor(uv.y), 2.0); //this is mod(genFType x, float y);
    return vec4(vec3(color), 1.0);
}
 

vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    //color is 0 to 1 and coord is 0 to res
    //R and B -> horizontal
    //G and A -> vertical
    //return vec4(fragCoord, fragCoord);
    
    //Fix: red and green only
    //R -> horizontal
    //G -> vertical
    //return vec4(fragCoord, 0.0, 1.0);
    
    //final: red-green gradient
    vec2 uv = fragCoord / iResolution.xy;
    return vec4(uv, 0.0, 1.0);
    
    //fun: red-green gradient
    //vec2 uv = fragCoord / resolution;
    //return vec4(0.5, uv, 1.0);
    
    //vec3 color = vec3(uv, 0.25);
    //float alpha = 1.0;
    //return vec4(color, alpha);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //Actual calling of functions for project
    
    // Effect 0
    fragColor = myEffect0(fragCoord, iResolution.xy);
    
    // Effect 1
    //fragColor = myEffect1Checkers(fragCoord);
    
    // Effect 2
    //fragColor = myEffect2Cricle(fragCoord, 0.3);
    
    // Effect 3
    //fragColor = myEffect3Trip(fragCoord);
    
    // Effect 4
    //fragColor = myEffect4Bonus(fragCoord);
    
    
    // Other notes taken in class
    // Also graident color change was written when file was made
    
    //R,G,B,A = [0,1]
    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);
    
    // Normalized pixel coordinates (from 0 to 1)
    //vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    //fragColor = vec4(col,1.0);
}