//using color = vec3;
//Any time useing 'colorRGB' it will be a vec3
#define colorRGB vec3

//Anytime used colorRGBA it will be a vec4
#define colorRGBA vec4


float circle(in vec2 st, in float radius){
    vec2 dist = st - vec2(0.5);
    return 1.-smoothstep(radius - (radius * 0.01),
                         radius + (radius * 0.01),
                         dot(dist, dist) * 4.0);

}

vec4 myEffect1(in vec2 fragCoord)
{
    //IMPORTANT THIS IS A TEMPLATE FOR MAKING CHECKER
    //LEARN WHAT IS HAPPENING AND MAKE IT YOUR OWN!!
    //GOTTON EXAMPLE: 
    
    //This Works!
    vec2 uv = fragCoord / vec2(500.0 - vec2(1));
    uv *= 7.0;	
    float col = mod(floor(uv.x) + floor(uv.y), 2.);
    return vec4(vec3(col), 1.0);
}
 

vec4 myEffect0(in vec2 fragCoord, in vec2 resolution)
{
    //color is 0 to 1 and coord is 0 to res
    //R and B -> horizontal
    //G and A -> vertical
    //return vec4(fragCoord, fragCoord);
    
    //Fix: red and green only
    //R -> horizontal
    //G -> vertical
    //return vec4(fragCoord, 0.0, 1.0);
    
    //final: red-green gradient
    //vec2 uv = fragCoord / iResolution.xy;
    //return vec4(uv, 0.0, 1.0);
    
    //fun: red-green gradient
    vec2 uv = fragCoord / resolution;
    //return vec4(0.5, uv, 1.0);
    
    vec3 color = vec3(uv, 0.25);
    float alpha = 1.0;
    return vec4(color, alpha);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 resolution = vec2(500. - vec2(1));
    
    //Effect 0
    //fragColor = myEffect0(fragCoord, iResolution.xy);
    
    //Effect 1
    //fragColor = myEffect1(fragCoord);
    
    //R,G,B,A = [0,1]
    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);
    
    //vec2 st = fragCoord.xy / vec2(100. - vec2(1));
    //vec3 color = vec3(circle(st, .5));
    //fragColor = vec4(color, 1.0);
    
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    fragColor = vec4(col,1.0);
}